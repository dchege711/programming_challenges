---
date: 2025-04-08
domains:
- learn.microsoft.com
draft: true
local_url: http://localhost:1313/computer-science/programming-challenges/language-concepts/meta-programming/dotnet-attributes/
title: Attributes and Reflection in C#
---

## Overview

When you compile code for the runtime, it is converted into common intermediate
language (CIL) and placed inside a portable executable (PE) file along with
metadata generated by the compiler. Attributes allow you to place extra
descriptive information into metadata that can be extracted using runtime
reflection services. {{% cite dotnetExtendMetadataWAttrs %}}

* Describe how to serialize data.
* Specify characteristics used to enforce security.
* Limit optimizations by the just-in-time (JIT) compiler so that the code
  remains easy to debug.

{{% cite dotnetExtendMetadataWAttrs %}}

## Custom Attribute Example

{{% comment %}}

Snippets runnable at https://godbolt.org/z/xYKqeqhMa.

{{% /comment %}}

### Defining an Attribute

```cs
using System;
using System.Reflection;

// By convention, all attribute names end with "Attribute".
// System.AttributeUsageAttribute is used to define key characteristics of the
// attribute, e.g., targets, inheritance, multiplicity, etc.
[AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = false)]
public class DeveloperAttribute : Attribute
{
  private string name;
  private string level;
  private bool reviewed;

  // Define required parameters like name and level as positional params.
  public DeveloperAttribute(string name, string level)
  {
    this.name = name;
    this.level = level;
    this.reviewed = false;
  }

  // Define Name property, a read-only attribute.
  public virtual string Name
  {
    get { return name; }
  }

  // Define Level property, a read-only attribute.
  public virtual string Level
  {
    get { return level; }
  }

  // Define Reviewed property, a read/write attribute. This can be set using
  // optional named parameters.
  public virtual bool Reviewed
  {
    get { return reviewed; }
    set { reviewed = value; }
  }
}
```

{{% cite dotnetWritingCustomAttrs %}}

`AttributeTargets` controls the program elements to which the attribute can be
applied, e.g., class, method, etc. {{% cite dotnetWritingCustomAttrs %}}

`AttributeUsageAttribute.Inherited` defines how the attribute propagates to
classes derived from a base class to which the attribute is applied.

```cs
// Defaults to Inherited = true
public class FooAttribute : Attribute {}

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
public class BarAttribute : Attribute {}

public class Base
{
  [Foo]
  [Bar]
  public virtual void Qux() {}
}

public class Derived
{
  // Qux will have the Foo attribute, but not the Bar attribute.
  public override void Qux() {}
}
```

{{% cite dotnetWritingCustomAttrs %}}

In a similar vein, `AttributeUsageAttribute.AllowMultiple` indicates whether
multiple instances of the attribute can exist on an element. It defaults to
`false`.

```cs
public class Foo
{
  // Is a compiler error if DeveloperAttribute set AllowMultiple = false.
  [Developer("Chege", "1")]
  [Developer("Atieno", "1")]
  public void Bar() {}
}
```

{{% cite dotnetWritingCustomAttrs %}}

If both `AllowMultiple` is set to `false` and `Inherited` is set to `true` (the
default behavior in both cases), then values of any attributes in the parent
class will be overwritten by new instances of the same attribute in the child
class. {{% cite dotnetWritingCustomAttrs %}}

### Using an Attribute

```cs
using System;
using System.Reflection;

// Although the attribute is called "DeveloperAttribute", you can drop the
// "Attribute" suffix when using the attribute.
[Developer("Joan Smith", "1")]
public class Foo
{
    [Developer("Joan Smith", "1", Reviewed = true)]
    static void Bar() {}
}

class Program
{
  static void Main()
  {
    // DeveloperAttribute for Foo: Name=Joan Smith, Level=1, Reviewed=False
    GetAttribute(typeof(Foo));
  }

  public static void GetAttribute(Type t)
  {
    DeveloperAttribute attr =
      (DeveloperAttribute) Attribute.GetCustomAttribute(t, typeof (DeveloperAttribute));
    
    if (attr is null)
    {
      Console.WriteLine("DeveloperAttribute not found.");
    }
    else
    {
      Console.WriteLine(
        "DeveloperAttribute for {0}: Name={1}, Level={2}, Reviewed={3}",
        t, attr.Name, attr.Level, attr.Reviewed);
    }
  }
}
```

{{% cite dotnetRetrievingInfoFromAttrs %}}

To retrieve all instances of the same attribute applied to the same scope, use
`Attribute.GetCustomAttributes` instead of `Attribute.GetCustomAttribute`. To
retrieve attribute instances across different scopes, e.g., for all methods in
class, you'd need to supply every scope, e.g.,

```cs
public static void PrintMethodAttributes(Type t)
{
  MemberInfo[] MyMemberInfo = t.GetMethods();
  for (int i = 0; i < MyMemberInfo.length; i++) {
    DeveloperAttribute attr =
      (DeveloperAttribute) Attribute.GetCustomAttribute(
          MyMemberInfo[i], typeof (DeveloperAttribute));
    // Print the attribute information to the console.
  }
}
```

... where methods like `Type.GetMethods`, `Type.GetProperties`, and
`Type.GetConstructors` come in handy. {{% cite dotnetRetrievingInfoFromAttrs %}}

## References

1. {{< citation
	id="dotnetExtendMetadataWAttrs"
	title="Extending Metadata Using Attributes - .NET"
	url="https://learn.microsoft.com/en-us/dotnet/standard/attributes/"
	accessed="2025-04-09" >}}

1. {{< citation
	id="dotnetWritingCustomAttrs"
	title="Writing Custom Attributes - .NET"
	url="https://learn.microsoft.com/en-us/dotnet/standard/attributes/writing-custom-attributes"
	accessed="2025-04-09" >}}

1. {{< citation
	id="dotnetRetrievingInfoFromAttrs"
	title="Retrieving Information Stored in Attributes - .NET"
	url="https://learn.microsoft.com/en-us/dotnet/standard/attributes/retrieving-information-stored-in-attributes"
	accessed="2025-04-09" >}}
